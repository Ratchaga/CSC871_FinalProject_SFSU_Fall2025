import torch
import torch.nn as nn
import torchvision.models as models
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns

from data_module import get_data_loaders

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")


# =========================================================
# LOAD DATA
# =========================================================
_, _, test_loader = get_data_loaders(
    data_root="chest_xray/chest_xray",
    batch_size=32,
    image_size=224
)


# =========================================================
# CNN BASELINE (custom sequential)
# =========================================================
def load_cnn():
    model = nn.Sequential(
        nn.Conv2d(3, 32, kernel_size=3, padding=1),
        nn.ReLU(),
        nn.MaxPool2d(2),

        nn.Conv2d(32, 64, kernel_size=3, padding=1),
        nn.ReLU(),
        nn.MaxPool2d(2),

        nn.Flatten(),
        nn.Linear(64 * 56 * 56, 128),
        nn.ReLU(),
        nn.Linear(128, 1)
    )

    state = torch.load("Person_B/cnn_model.pth", map_location=device)
    model.load_state_dict(state)
    model.to(device)
    model.eval()
    return model


# =========================================================
# RESNET18 (binary)
# =========================================================
def load_resnet18():
    model = models.resnet18(weights=None)
    model.fc = nn.Linear(512, 1)
    state = torch.load("Person_B/resnet18_weights.pth", map_location=device)
    model.load_state_dict(state)
    model.to(device)
    model.eval()
    return model


# =========================================================
# RESNET50 (binary)
# =========================================================
def load_resnet50():
    model = models.resnet50(weights=None)
    model.fc = nn.Linear(2048, 1)
    state = torch.load("Person_B/resnet50_weights.pth", map_location=device)
    model.load_state_dict(state)
    model.to(device)
    model.eval()
    return model


# =========================================================
# DENSENET121 (2-output softmax)
# =========================================================
def load_densenet121():
    model = models.densenet121(weights=None)

    # Person B trained 2 outputs (NOT 1)
    model.classifier = nn.Linear(1024, 2)

    state = torch.load("Person_B/densenet121_weights.pth", map_location=device)
    model.load_state_dict(state)

    model.to(device)
    model.eval()
    return model


# =========================================================
# EFFICIENTNET-B0 (2-output softmax)
# =========================================================
def load_efficientnet_b0():
    model = models.efficientnet_b0(weights=None)

    # Person B trained 2 outputs (NOT 1)
    model.classifier[1] = nn.Linear(1280, 2)

    state = torch.load("Person_B/efficientnet_b0_weights.pth", map_location=device)
    model.load_state_dict(state)

    model.to(device)
    model.eval()
    return model


# =========================================================
# EVALUATION FUNCTION
# =========================================================
def evaluate_model(model, loader, model_name):
    y_true, y_pred = [], []

    model.eval()
    with torch.no_grad():
        for images, labels in loader:
            images, labels = images.to(device), labels.to(device)

            logits = model(images)

            if model_name in ["DenseNet121", "EfficientNet-B0"]:
                # Multi-class softmax models
                probs = torch.softmax(logits, dim=1)
                preds = probs.argmax(dim=1)

            else:
                # Binary sigmoid models
                probs = torch.sigmoid(logits).squeeze(1)
                preds = (probs > 0.5).long()

            y_true.extend(labels.cpu().numpy())
            y_pred.extend(preds.cpu().numpy())

    acc = accuracy_score(y_true, y_pred)
    prec = precision_score(y_true, y_pred, zero_division=0)
    rec = recall_score(y_true, y_pred, zero_division=0)
    f1 = f1_score(y_true, y_pred, zero_division=0)

    print(f"\n=== {model_name} ===")
    print(f"Accuracy:  {acc:.4f}")
    print(f"Precision: {prec:.4f}")
    print(f"Recall:    {rec:.4f}")
    print(f"F1 Score:  {f1:.4f}")

    # CONFUSION MATRIX PLOT
    cm = confusion_matrix(y_true, y_pred)
    plt.figure(figsize=(6, 5))
    sns.heatmap(
        cm,
        annot=True,
        fmt="d",
        cmap="Blues",
        xticklabels=["NORMAL", "PNEUMONIA"],
        yticklabels=["NORMAL", "PNEUMONIA"]
    )
    plt.title(f"{model_name} Confusion Matrix")
    plt.xlabel("Predicted")
    plt.ylabel("Actual")
    plt.tight_layout()
    plt.savefig(f"{model_name.lower().replace(' ', '_')}_confusion.png")
    plt.close()


# =========================================================
# RUN ALL MODELS
# =========================================================
models_to_run = {
    "CNN Baseline": load_cnn,
    "ResNet18": load_resnet18,
    "ResNet50": load_resnet50,
    "DenseNet121": load_densenet121,
    "EfficientNet-B0": load_efficientnet_b0,
}

for name, fn in models_to_run.items():
    print(f"\nLoading {name} ...")
    model = fn()
    evaluate_model(model, test_loader, name)

print("\nðŸŽ‰ All models evaluated successfully!")
